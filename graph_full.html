<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Network Graph â€” Full View</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
  <style>
    html,body { height:100%; margin:0; background:#f5f5f5; font-family: Lato, Helvetica, sans-serif; }
    #network-graph { width:100vw; height:100vh; background: #fff; position:relative; overflow:hidden; }
    /* tooltip exists but we'll not use it on full page (kept for safe fallback) */
    .graph-tooltip { position: fixed; display:none; background: rgba(0,0,0,0.92); color:#fff; padding:8px 10px; border-radius:4px; z-index:2000; font-size:13px; max-width:320px; box-shadow: 0 2px 8px rgba(0,0,0,0.4); }
    .links line { stroke-opacity:0.6; transition: stroke-opacity .15s, stroke-width .15s; }
    .nodes circle { stroke:#fff; stroke-width:1.5px; cursor:grab; transition: stroke-width .15s; }
    .nodes circle:hover { stroke-width:3px; stroke:#FFD700; }
    .nodes circle.highlighted { stroke:#FFD700; stroke-width:3px; }
    .nodes circle.dimmed { opacity:0.12; }
    .links line.highlighted { stroke-opacity:1; }
    .links line.dimmed { stroke-opacity:0.06; }
    .node-labels text { font-size:11px; pointer-events:none; text-anchor:middle; fill:#000; font-weight:500; }
  </style>
</head>
<body>
  <div id="network-graph"><div class="graph-tooltip" id="graph-tooltip"></div></div>

  <script>
  (function(){
    const containerId = 'network-graph';
    const tooltipId = 'graph-tooltip';
    const width = window.innerWidth;
    const height = window.innerHeight;
    const dataFile = 'graph_data_with_layout.json';

    const container = d3.select('#' + containerId);
    // prevent double init
    if (container.select('svg').size() > 0) { console.warn('Full graph already initialized'); return; }

    const svg = container.append('svg').attr('width', width).attr('height', height);
    const g = svg.append('g');

    const zoom = d3.zoom().scaleExtent([0.25, 6]).on('zoom', (e)=> g.attr('transform', e.transform));
    svg.call(zoom);
    svg.node().addEventListener('wheel', function(e){ e.preventDefault(); }, { passive: false });
    svg.on("dblclick.zoom", null); // disable dblclick zoom

    const linkGroup = g.append('g').attr('class','links');
    const nodeGroup = g.append('g').attr('class','nodes');
    const labelGroup = g.append('g').attr('class','node-labels');

    let linkElements, nodeElements, labelElements, simulation;

    function edgeColorFromWeight(w) {
      const mag = Math.min(1, Math.abs(w || 0));
      const gray = Math.round(255 - 125 * mag);
      return `rgb(${gray},${gray},${gray})`;
    }

    function loadGraph(data) {
      linkGroup.selectAll('*').remove();
      nodeGroup.selectAll('*').remove();
      labelGroup.selectAll('*').remove();

      // store original JSON coordinates so we can snap back exactly
      data.nodes.forEach(n => {
        n.origX = (n.x !== undefined) ? n.x : null;
        n.origY = (n.y !== undefined) ? n.y : null;
      });

      const hasLayout = data.nodes.length && data.nodes[0].origX !== null;
      if (hasLayout) {
        const xExtent = d3.extent(data.nodes, d => d.origX);
        const yExtent = d3.extent(data.nodes, d => d.origY);
        const padding = Math.min(width, height) * 0.05;
        const scale = Math.min((width - 2*padding) / (xExtent[1]-xExtent[0] || 1),
                               (height - 2*padding) / (yExtent[1]-yExtent[0] || 1));
        data.nodes.forEach(n => {
          // store scaled positions so we can use them as starting positions
          n.x = padding + (n.origX - xExtent[0]) * scale;
          n.y = padding + (n.origY - yExtent[0]) * scale;
        });
      }

      simulation = d3.forceSimulation(data.nodes)
        .force('link', d3.forceLink(data.links).id(d=>d.id).distance(30))
        .force('charge', d3.forceManyBody().strength(-120))
        .force('center', d3.forceCenter(width/2, height/2))
        .force('collision', d3.forceCollide().radius(d => Math.max(6, Math.sqrt(d.degree||1)*1.5)))
        .alphaDecay(0.06);

      linkElements = linkGroup.selectAll('line')
        .data(data.links).enter().append('line')
        .attr('stroke', d => edgeColorFromWeight(d.weight !== undefined ? d.weight : (d.value !== undefined ? d.value : 0.5)))
        .attr('stroke-width', d => Math.max(1.0, Math.abs(d.weight !== undefined ? d.weight : (d.value !== undefined ? d.value : 1.0)) * 2.5));

      nodeElements = nodeGroup.selectAll('circle')
        .data(data.nodes).enter().append('circle')
        .attr('r', d => Math.max(3, Math.sqrt(d.degree||1)*1.6 + 2))
        .attr('fill', d => d.color || '#999')
        .on('mouseover', handleMouseOver)
        .on('mouseout', handleMouseOut)
        .call(d3.drag()
          .on('start', dragStarted)
          .on('drag', dragged)
          .on('end', dragEnded));

      labelElements = labelGroup.selectAll('text')
        .data(data.nodes).enter().append('text')
        .text(d => d.name || d.id)
        .attr('font-size','11px')
        .attr('text-anchor','middle')
        .attr('pointer-events','none')
        .attr('fill','#000')
        .attr('dy', d => Math.max(3, Math.sqrt(d.degree||1)*1.6 + 2) + 14)
        .style('display','none');

      simulation.on('tick', () => {
        linkElements
          .attr('x1', d => d.source.x)
          .attr('y1', d => d.source.y)
          .attr('x2', d => d.target.x)
          .attr('y2', d => d.target.y);
        nodeElements
          .attr('cx', d => d.x)
          .attr('cy', d => d.y);
        labelElements
          .attr('x', d => d.x)
          .attr('y', d => d.y);
      });

      // If layout provided, hold positions briefly so user sees saved layout,
      // then release so drag/physics work normally.
      if (hasLayout) {
        data.nodes.forEach(n => { n.fx = n.x; n.fy = n.y; });
        setTimeout(() => {
          data.nodes.forEach(n => { n.fx = null; n.fy = null; });
          simulation.alpha(0.45).restart();
        }, 350);
      }

      // fit to view
      setTimeout(() => {
        try {
          const b = g.node().getBBox();
          const scale = 0.85 * Math.min(width / b.width, height / b.height);
          const tx  = width/2 - scale*(b.x + b.width/2);
          const ty  = height/2 - scale*(b.y + b.height/2);
          svg.transition().duration(600).call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(scale));
        } catch(e) {}
      }, 600);
    }

    function dragStarted(event, d) {
      if (!event.active) s
